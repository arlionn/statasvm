#!/usr/bin/awk -f

# TODO: instead of just printing extra blanks between sections
#       keep a second trigger variable and intelligently place extra space around the code blocks when they start or finish

BEGIN {
  F=FILENAME
  if(PKG=="") {
    PKG="UNKNOWN_PACKAGE"
  }
  print "{* This file was generated by scripts/examples2smcl.}{...}"
  print "{* It is included by the " PKG ".sthlp file to embed the examples/ folder into the documentation.}{...}"
  print "{...}"
}

# handle the start of a new example .do file
# 
# this is an edge-triggered event handler
# triggered by FILENAME changing values
# (we track the old value in F).
F != FILENAME {
  
  if(F) {
      close_example()
      # if there was a previous file
  }
  
  F=FILENAME
  
  open_example()
}

# these are an if-else chain
# where the 'else' is "they didn't hit the 'next' command"
/^[[:space:]]*\/\*/ {
  # bolded comments 
  sub("^[[:space:]]*/\\*","")
  sub("[[:space:]]*\\*/[[:space:]]*","")
  print "{pstd}{bf:" $0 "}{p_end}"
  next
}

/^[[:space:]]*\/\/[[:space:]]*/ {
  # regular comments
  sub("^[[:space:]]*\/\/[[:space:]]*", "")
  print "{pstd}" $0 "{p_end}"
  next
}

/^[[:space:]]*$/ {
  # blank lines
  print ""
  next
}

{
  # everything else is code
  print "{phang2}{cmd:. " $0 "}{p_end}"
  next
}


END {
  close_example()
}


function open_example() {
  # print the filename as a section header
  #extract basename, without the _example.do suffix 
  DESC=example_basename(FILENAME)
  # underscores to spaces
  gsub("_"," ",DESC)
  print "{title:Examples: " DESC "}"
  print "" #blank line
  #print "{hline}"
}

function close_example() {
  # close the current one's tags
  #print "{hline}"
  print ""
  print "{pstd}{it:({stata " PKG "_example " example_basename(F) ":click to run})}{p_end}"
  print ""
}


function example_basename(n) {
  n = basename(n)
  sub("_example$", "", n)
  return n
}



## Utilities
function basename(n) {
  # strip everything up to the path separator
  if(ENVIRON["OS"] == "Windows_NT") {
    # \\\\ means "\", but it has to be escaped two-levels deep for some reason
    sub("^.*\\\\","",n)
  } else {
    # assume POSIX with /
    sub("^.*/","",n)
  }
  # strip the suffix
  # \\. means a literal "."; again, there's two layers of escaping necessary
  sub("\\..*$","",n)
  return n
}
