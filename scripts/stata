#!/bin/sh
# a wrapper for Stata to make it more behave like a Unix interpreter:
# - the last argument is a .do file to run
# - the output is sent to stdout
# But because of how Stata is hard-coded
# 1) if you script is named script.do and you happen to have script.log in the current directory, it will be stomped
# 2) you won't see output until the entire script is finished

# TODO: try to auto-locate Stata based on platform, and pull the corresponding spaghetti code out of test.mk
# TODO: write Stata.bat so this works on Wandows too


STATA=stata
if [ "$(uname)" = "Darwin" ]; then
  PATH=/Applications/Stata/Stata.app/Contents/MacOS/:$PATH
  # Note: Stata installs to /Applications/Stata/Stata.app/Contents/MacOS/Stata on OS X,
  #       but OS X is happily case-insensitive.
fi

if ! which "$STATA" >/dev/null 2>/dev/null; then
  echo "Stata not found."
  exit 1
fi

SCRIPT="$1"; shift

# TODO: detect if we're pointed at console Stata or GUI Stata
# GUI Stata (which is all you get on OS X and Windows) can only be automated with -e,
#  which requires running the thing and waiting for it to spit out a logfile which we then parse

# make 
if (mktemp --version 2>/dev/null | grep GNU); then
  # GNU and 
  # Under GNU -p "" means use /tmp or other system-defined default
  CRUFT=$(mktemp -d -p "" "$TEMPLATE")
else
  # Assume BSD mktemp
  CRUFT=$(mktemp -d -t statawrap)
fi

WRAPPER="$CRUFT"/wrapped.do
LOG="$CRUFT"/session.log
RC="$CRUFT"/rc

# This Stata script wraps $SCRIPT so that its output goes to $LOG and error code to $RC,
# and it ensures Stata comes down at the end even if there was an error.
# - almost: $LOG ends up with header and footer cruft from 'log', unfortunately, and *this is a variable number of lines*
cat > "$WRAPPER" <<EOF
log using "$LOG", text
capture noisily do "$SCRIPT"
log close
shell echo "\`=_rc'" > "$RC"
exit, clear STATA
EOF

$STATA -q -e do "$WRAPPER"

cat $LOG
RC=$(cat "$RC")
rm -r $CRUFT
exit $RC
